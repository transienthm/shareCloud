- Object类有哪些方法
```
protected Object	clone()

boolean	equals(Object obj)
protected void	finalize()
Class<?>	getClass()
int	hashCode()
void	notify()
void	notifyAll()
String	toString()
void	wait()
void	wait(long timeout)
void	wait(long timeout, int nanos)
```

- Yield功能
线程状态中，从可运行到运行中之间，是由cpu进行选择的，线程yield之后，可以从运行中状态回到可运行状态，由其他线程执行。但是可能会被OS再次选中。


介绍一下Java中volatile关键字
项目中你用到这个关键字吗，用于哪个场景
Volatitle关键字声明之后，编译器不会优化的原理
Java中Session和Cookie
Cookie如果我不想js或http读，应该设置什么属性
里面有个属性httpOnly，这个属性你了解吗
如何防止跨站点攻击
Java中Synchronized，Lock的区别
Synchronized能被中断吗
Lock中提供了中断的方法吗，这个方法是哪个
消费者生产者模型你是怎么实现的
如果当前线程被锁，其它线程干嘛
具体在哪个场景中使用这个，业务背景
在工程中用的还是分布式管理
hashMap是怎么管理的
线程安全版本你用过吗
ConcurrentHashMap用过吗，讲一下原理
怎么执行读时被锁
除了分段锁还有什么原理
怎么用于分布式
线程本地变量原理和实现原理
线程本地变量大概有什么数据结构，怎么实现的
介绍一下java的内存模型
除了堆，栈，常量区还有什么
线程本地变量存在哪的
JVM的DDM参数你有调优过吗，设置大小和原则你能介绍一下吗
Xss默认大小，在实际项目中你一般会设置多大

数据库主键和外键有什么区别
数据库视图和表有什么区别
数据事务你能简单介绍一下吗，ACCD
事务特性分别什么特征，什么原理
Mysql数据库隔离级别一般用哪个
Hibernate隔离级别一般用的哪个
数据库大概怎么实现的索引，底层用了什么数据结构，大概介绍一下
B 树
分布式系统，分布式工作原理

介绍ARP协议是干什么的
Http请求底层是用的什么协议
Tcp连接过程
连接时队列大小是什么原理
DNS协议作用，底层用的什么协议

语法解析
词法解析
编译步骤分几个部分
编译程序常用表达方法

进程通信有哪些方式
进程和线程有什么区别
文件描述符是共享的还是私有的

什么是死锁
Java中你碰到过死锁吗
Mysql中碰到过死锁吗
虚拟内存是什么原理
一页大小大概多少
换页中最近最长未使用算法简单的实现
除外链表相应算法你了解过吗

堆排序大概是怎么实现的
堆排序你使用过吗，是用的怎样的底层存储，数据结构
底层是用的数组，逻辑上是怎样的结构
求第五大的算法是什么原理，直接求，不用排序
搜索算法PN你知道吗，字符串查找
介绍一下你学过哪些搜索算法
B 用于外排为什么效率会比较高
B 树结点大小一般是多大
和磁盘块大小有什么关系
Hash算法是什么，为什么会有Hash算法
一般采用的Hash冲突有哪些解决方案
一次性Hash你有了解吗

Redis的哪些常见的数据结构
怎么保证分布式Catch出现脏数据
Maven包冲突怎么解决
Maven有什么命令可以解决包冲突
Maven怎么把所有包打包
Linux中怎么看日志中某个时间段某个网站被各个ip访问的次数

- Linux中解压命令是什么
tar -xvzf

- 乐观锁与悲观锁
悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。[1]      悲观锁假定其他用户企图访问或者改变你正在访问、更改的对象的概率是很高的，因此在悲观锁的环境中，在你开始改变此对象之前就将该对象锁住，并且直到你提交了所作的更改之后才释放锁。悲观的缺陷是不论是页锁还是行锁，加锁的时间可能会很长，这样可能会长时间的限制其他用户的访问，也就是说悲观锁的并发访问性不好。
乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。[1] 乐观锁不能解决脏读的问题。    乐观锁则认为其他用户企图改变你正在更改的对象的概率是很小的，因此乐观锁直到你准备提交所作的更改时才将对象锁住，当你读取以及改变该对象时并不加锁。可见乐观锁加锁的时间要比悲观锁短，乐观锁可以用较大的锁粒度获得较好的并发访问性能。但是如果第二个用户恰好在第一个用户提交更改之前读取了该对象，那么当他完成了自己的更改进行提交时，数据库就会发现该对象已经变化了，这样，第二个用户不得不重新读取该对象并作出更改。这说明在乐观锁环境中，会增加并发用户读取对象的次数。
在实际生产环境里边,如果并发量不大且不允许脏读，可以使用悲观锁解决并发问题；但如果系统的并发非常大的话,悲观锁定会带来非常大的性能问题,所以我们就要选择乐观锁定的方法.

项目中你用过最高深的技术，能大概介绍一下吗
你现在在看什么书
书中你觉得你比较有体会的有价值的
Java8
你介绍一下你技术方面学习规划

你有什么问题想问我的吗
